using Open.IO;
using Open.Net.Http;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Open.Mega
{
    public class MegaClient
    {
        private static readonly Uri BaseApiUri = new Uri("https://g.api.mega.co.nz/cs");
        private uint _sequenceIndex = (uint)(uint.MaxValue * new Random().NextDouble());
        private string _sessionId;
        private byte[] _masterKey;

        public MegaClient()
        {
        }

        /// <summary>
        /// Login to Mega.co.nz service using email/password credentials
        /// </summary>
        /// <param name="email">email</param>
        /// <param name="password">password</param>
        /// <exception cref="ApiException">Service is not available or credentials are invalid</exception>
        /// <exception cref="ArgumentNullException">email or password is null</exception>
        /// <exception cref="NotSupportedException">Already logged in</exception>
        public async Task Login(string email, string password, CancellationToken cancellationToken)
        {
            await Login(await GenerateAuthInfos(email, password), cancellationToken);
        }

        /// <summary>
        /// Generate authentication informations and store them in a serializable object to allow persistence
        /// </summary>
        /// <param name="email">email</param>
        /// <param name="password">password</param>
        /// <returns><see cref="AuthInfos" /> object containing encrypted data</returns>
        /// <exception cref="ArgumentNullException">email or password is null</exception>
        public static async Task<AuthInfo> GenerateAuthInfos(string email, string password)
        {
            if (string.IsNullOrEmpty(email))
            {
                throw new ArgumentNullException("email");
            }

            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentNullException("password");
            }

            // Retrieve password as UTF8 byte array
            byte[] passwordBytes = password.ToBytes();

            // Encrypt password to use password as key for the hash

            var passwordAesKey = await PrepareKey(passwordBytes);

            // Hash email and password to decrypt master key on Mega servers
            string hash = await GenerateHash(email.ToLowerInvariant(), passwordAesKey);

            return new AuthInfo(email, hash, passwordAesKey);
        }

        /// <summary>
        /// Login to Mega.co.nz service using hashed credentials
        /// </summary>
        /// <param name="authInfos">Authentication informations generated by <see cref="GenerateAuthInfos"/> method</param>
        /// <exception cref="ApiException">Service is not available or authInfos is invalid</exception>
        /// <exception cref="ArgumentNullException">authInfos is null</exception>
        /// <exception cref="NotSupportedException">Already logged in</exception>
        public async Task Login(AuthInfo authInfos, CancellationToken cancellationToken)
        {
            if (authInfos == null)
            {
                throw new ArgumentNullException("authInfos");
            }

            //this.EnsureLoggedOut();

            // Request Mega Api
            var request = new LoginRequest(authInfos.Email, authInfos.Hash);
            LoginResponse response = await this.Post<LoginRequest, LoginResponse>(request, cancellationToken);

            // Decrypt master key using our password key
            byte[] cryptedMasterKey = response.MasterKey.FromBase64();
            this._masterKey = Crypto.DecryptKey(cryptedMasterKey, authInfos.PasswordAesKey);

            // Decrypt RSA private key using decrypted master key
            byte[] cryptedRsaPrivateKey = response.PrivateKey.FromBase64();
            BigInteger[] rsaPrivateKeyComponents = Crypto.GetRsaPrivateKeyComponents(cryptedRsaPrivateKey, this._masterKey);

            // Decrypt session id
            byte[] encryptedSid = response.SessionId.FromBase64();
            byte[] sid = Crypto.RsaDecrypt(encryptedSid.FromMPINumber(), rsaPrivateKeyComponents[0], rsaPrivateKeyComponents[1], rsaPrivateKeyComponents[2]);

            // Session id contains only the first 43 decrypted bytes
            this._sessionId = sid.CopySubArray(43).ToBase64();
        }

        /// <summary>
        /// Retrieve all filesystem nodes
        /// </summary>
        /// <returns>Flat representation of all the filesystem nodes</returns>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        public async Task<IEnumerable<Node>> GetNodes(CancellationToken cancellationToken)
        {
            //this.EnsureLoggedIn();

            GetNodesRequest request = new GetNodesRequest();
            GetNodesResponse response = await Post<GetNodesRequest, GetNodesResponse>(request, cancellationToken);

            Node[] nodes = response.Nodes;
            foreach (var node in nodes)
            {
                DecriptNode(node, response);
            }
            return nodes;
        }

        public async Task<Node> Upload(Stream fileContent, string name, Node parent, IProgress<StreamProgress> progress, CancellationToken cancellationToken)
        {
            if (fileContent == null)
            {
                throw new ArgumentNullException("fileContent");
            }

            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (parent.Type == NodeType.File)
            {
                throw new ArgumentException("Invalid parent node");
            }

            //this.EnsureLoggedIn();
            // Retrieve upload URL
            var length = fileContent.GetLength();
            if (!length.HasValue)
            {
                fileContent = new MemoryStream(await fileContent.ReadAsBufferAsync(cancellationToken));
                length = fileContent.GetLength();
            }
            UploadUrlRequest uploadRequest = new UploadUrlRequest(length.Value);
            UploadUrlResponse uploadResponse = await Post<UploadUrlRequest, UploadUrlResponse>(uploadRequest, cancellationToken);

            var megaStream = new MegaEncryptStream(fileContent);
            string completionHandle;
            try
            {
                completionHandle = await PostRaw(new Uri(uploadResponse.Url), megaStream, progress, cancellationToken);
            }
            finally
            {
                megaStream.Dispose();
            }

            // Encrypt attributes
            byte[] cryptedAttributes = EncryptAttributes(new Attributes(name), megaStream.FileKey);

            // Compute the file key
            byte[] fileKey = new byte[32];
            for (int i = 0; i < 8; i++)
            {
                fileKey[i] = (byte)(megaStream.FileKey[i] ^ megaStream.IV[i]);
                fileKey[i + 16] = megaStream.IV[i];
            }

            for (int i = 8; i < 16; i++)
            {
                fileKey[i] = (byte)(megaStream.FileKey[i] ^ megaStream.MetaMac[i - 8]);
                fileKey[i + 16] = megaStream.MetaMac[i - 8];
            }

            byte[] encryptedKey = Crypto.EncryptKey(fileKey, this._masterKey);

            CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest(parent, cryptedAttributes.ToBase64(), encryptedKey.ToBase64(), completionHandle);
            GetNodesResponse createNodeResponse = await Post<CreateNodeRequest, GetNodesResponse>(createNodeRequest, cancellationToken);
            var node = createNodeResponse.Nodes[0];
            DecriptNode(node, createNodeResponse);
            return node;
        }

        public async Task<Stream> Download(Node node, CancellationToken cancellationToken)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (node.Type != NodeType.File)
            {
                throw new ArgumentException("Invalid node");
            }

            //this.EnsureLoggedIn();

            // Retrieve download URL
            var downloadRequest = new DownloadUrlRequest(node);
            var downloadResponse = await Post<DownloadUrlRequest, DownloadUrlResponse>(downloadRequest, cancellationToken);

            var client = CreateClient();
            var response = await client.GetAsync(new Uri(downloadResponse.Url), HttpCompletionOption.ResponseHeadersRead, cancellationToken);
            var content = response.Content;
            if (!content.Headers.ContentLength.HasValue)
            {
                throw new Exception("Stream length cannot be computed");
            }
            var stream = await content.ReadAsStreamAsync();
            return new MegaDecryptStream(stream, content.Headers.ContentLength.Value, node.Key, node.Iv, node.MetaMac);
        }

        public async Task<Node> CreateFolder(string name, Node parent, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (parent.Type == NodeType.File)
            {
                throw new ArgumentException("Invalid parent node");
            }

            //this.EnsureLoggedIn();
            var key = Crypto.CreateAesKey();
            byte[] attributes = EncryptAttributes(new Attributes(name), key);
            byte[] encryptedKey = Crypto.EncryptAes(key, this._masterKey);

            CreateNodeRequest request = CreateNodeRequest.CreateFolderNodeRequest(parent, attributes.ToBase64(), encryptedKey.ToBase64());
            GetNodesResponse response = await Post<CreateNodeRequest, GetNodesResponse>(request, cancellationToken);

            var node = response.Nodes[0];
            DecriptNode(node, response);
            return node;
        }

        public async Task<int> RenameNode(Node node, string name, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            //if (node.Type == NodeType.File)
            //{
            //    throw new ArgumentException("Invalid parent node");
            //}

            //this.EnsureLoggedIn();
            byte[] attributes = EncryptAttributes(new Attributes(name), node.Key);
            byte[] encryptedKey = Crypto.EncryptAes(node.Key, this._masterKey);

            var request = new SetAttributesRequest(node, attributes.ToBase64(), encryptedKey.ToBase64());
            return await Post<SetAttributesRequest, int>(request, cancellationToken);
        }

        public async Task<int> Delete(Node node, CancellationToken cancellationToken)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (node.Type != NodeType.Directory && node.Type != NodeType.File)
            {
                throw new ArgumentException("Invalid node type");
            }

            //this.EnsureLoggedIn();
            return await Post<DeleteRequest, int>(new DeleteRequest(node), cancellationToken);
        }

        public async Task<int> Move(Node node, Node destinationParentNode, CancellationToken cancellationToken)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (destinationParentNode == null)
            {
                throw new ArgumentNullException("destinationParentNode");
            }

            if (node.Type != NodeType.Directory && node.Type != NodeType.File)
            {
                throw new ArgumentException("Invalid node type");
            }

            if (destinationParentNode.Type == NodeType.File)
            {
                throw new ArgumentException("Invalid destination parent node");
            }
            return await Post<MoveRequest, int>(new MoveRequest(node, destinationParentNode), cancellationToken);
        }

        #region ** implementation

        private static async Task<string> GenerateHash(string email, byte[] passwordAesKey)
        {
            byte[] emailBytes = email.ToBytes();
            byte[] hash = new byte[16];

            // Compute email in 16 bytes array
            for (int i = 0; i < emailBytes.Length; i++)
            {
                hash[i % 16] ^= emailBytes[i];
            }

            await Task.Run(() =>
            {
                var hashBuffer = hash;
                // Encrypt hash using password key
                for (int it = 0; it < 16384; it++)
                {
                    hashBuffer = Crypto.EncryptAes(hashBuffer, passwordAesKey);
                }
                hash = hashBuffer;
            });

            // Retrieve bytes 0-4 and 8-12 from the hash
            byte[] result = new byte[8];
            Array.Copy(hash, 0, result, 0, 4);
            Array.Copy(hash, 8, result, 4, 4);

            return result.ToBase64();
        }

        private static async Task<byte[]> PrepareKey(byte[] data)
        {
            var pkey = new byte[] { 0x93, 0xC4, 0x67, 0xE3, 0x7D, 0xB0, 0xC7, 0xA4, 0xD1, 0xBE, 0x3F, 0x81, 0x01, 0x52, 0xCB, 0x56 };
            await Task.Run(() =>
                {
                    var keys = new object[(int)Math.Ceiling((double)data.Length / 16.0)];
                    for (int idx = 0; idx < data.Length; idx += 16)
                    {
                        // Pad the data to 16 bytes blocks
                        var key = data.CopySubArray(16, idx);
                        // create symmetric key from derived password key
                        keys[idx / 16] = key;
                    }
                    for (int it = 0; it < 65536; it++)
                    {
                        foreach (byte[] key in keys)
                        {
                            pkey = Crypto.EncryptAes(pkey, key);
                        }
                    }
                });
            return pkey;
        }

        private void DecriptNode(Node node, GetNodesResponse response)
        {
            node.LastModificationDate = Node.OriginalDateTime.AddSeconds(node.SerializedLastModificationDate).ToLocalTime();
            if (node.Type == NodeType.File || node.Type == NodeType.Directory)
            {
                string serializedKey = node.SerializedKey;
                int splitPosition = serializedKey.IndexOf(":");
                byte[] encryptedKey = serializedKey.Substring(splitPosition + 1).FromBase64();

                var decryptedKey = Crypto.DecryptKey(encryptedKey, _masterKey);
                node.Key = decryptedKey;

                // If node is shared, we need to retrieve shared masterkey
                if (response.SharedKeys != null)
                {
                    string owner = splitPosition > -1 ? serializedKey.Substring(0, splitPosition) : serializedKey;
                    var sharedKey = response.SharedKeys.FirstOrDefault(x => x.Id == owner);
                    if (sharedKey != null)
                    {
                        var masterKey = Crypto.DecryptKey(sharedKey.Key.FromBase64(), _masterKey);

                        if (node.Type == NodeType.Directory)
                        {
                            decryptedKey = masterKey;
                        }

                        node.Key = Crypto.DecryptKey(encryptedKey, masterKey);
                    }
                }

                if (node.Type == NodeType.File)
                {
                    // Extract Iv and MetaMac
                    byte[] iv = new byte[8];
                    byte[] metaMac = new byte[8];
                    Array.Copy(decryptedKey, 16, iv, 0, 8);
                    Array.Copy(decryptedKey, 24, metaMac, 0, 8);
                    node.Iv = iv;
                    node.MetaMac = metaMac;

                    // For files, key is 256 bits long. Compute the key to retrieve 128 AES key
                    node.Key = new byte[16];
                    for (int idx = 0; idx < 16; idx++)
                    {
                        node.Key[idx] = (byte)(decryptedKey[idx] ^ decryptedKey[idx + 16]);
                    }
                }

                Attributes attributes = DecryptAttributes(node.SerializedAttributes.FromBase64(), node.Key);
                node.Name = attributes.Name;
            }
            //if (this._trashNode == null)
            //{
            //    this._trashNode = nodes.First(n => n.Type == NodeType.Trash);
            //}
        }

        private static byte[] EncryptAttributes(Attributes attributes, byte[] nodeKey)
        {
            string data = "MEGA" + attributes.SerializeJson();
            byte[] dataBytes = data.ToBytes();
            dataBytes = dataBytes.CopySubArray(dataBytes.Length + 16 - (dataBytes.Length % 16));

            return Crypto.EncryptAes(dataBytes, nodeKey);
        }

        private static Attributes DecryptAttributes(byte[] attributes, byte[] nodeKey)
        {
            byte[] decryptedAttributes = Crypto.DecryptAes(attributes, nodeKey);

            // Remove MEGA prefix
            try
            {
                return decryptedAttributes.ToUTF8String().Substring(4).Trim('\0').DeserializeJson<Attributes>();
            }
            catch (Exception ex)
            {
                return new Attributes(string.Format("Attribute deserialization failed: {0}", ex.Message));
            }
        }

        private async Task<string> PostRaw(Uri uri, Stream buffer, IProgress<StreamProgress> progress, CancellationToken cancellationToken)
        {
            var client = CreateClient();
            var content = new StreamedContent(buffer, progress, cancellationToken);
            //client.DefaultRequestHeaders.UserAgent.ParseAdd("MegaApiClient v1.0");//.Add(new HttpProductInfoHeaderValue("MegaApiClient v1.0"));
            //client.DefaultRequestHeaders.Expect.Add(new HttpExpectationHeaderValue("100-continue"));
            //client.DefaultRequestHeaders.Connection.Clear();
            //client.DefaultRequestHeaders.AcceptEncoding.Clear();
            content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
            //content.Headers.ContentEncoding.Add(new HttpContentCodingHeaderValue("base64"));
            var response = await client.PostAsync(uri, content, cancellationToken);//.AsTask(cancellationToken, progress);
            return await response.Content.ReadAsStringAsync();
        }

        private async Task<TResponse> Post<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
            where TRequest : RequestBase
        {
            string dataRequest = (new TRequest[] { request }).SerializeJson<TRequest[]>();
            Uri uri = this.GenerateUrl();
            var client = CreateClient();
            var content = new ByteArrayContent(Encoding.UTF8.GetBytes(dataRequest));
            content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
            var response = await client.PostAsync(uri, content, cancellationToken);
            try
            {
                return (await response.Content.ReadJsonAsync<TResponse[]>()).First();
            }
            catch
            {
                var contentString = await response.Content.ReadAsStringAsync();
                try
                {
                    var codes = contentString.DeserializeJson<int[]>();
                    throw new MegaException(codes);
                }
                catch
                {
                    int code;
                    if (int.TryParse(contentString, out code))
                    {
                        throw new MegaException(new int[] { code });
                    }
                    throw;
                }
            }
        }

        private Uri GenerateUrl()
        {
            UriBuilder builder = new UriBuilder(BaseApiUri);
            var query = "id=" + (_sequenceIndex++ % uint.MaxValue).ToString(CultureInfo.InvariantCulture);

            if (!string.IsNullOrEmpty(this._sessionId))
            {
                query += "&sid=" + this._sessionId;
            }

            builder.Query = query.ToString();
            return builder.Uri;
        }

        private static HttpClient CreateClient()
        {
            var client = new HttpClient(new MegaRetryFilter());
            client.Timeout = Timeout.InfiniteTimeSpan;
            return client;
        }

        #endregion
    }
}
